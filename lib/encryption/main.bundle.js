function q(t){return new Promise((r,i)=>{let n=document.createElement("script");n.src=t,n.onload=()=>r(n),n.onerror=o=>i(o),document.head.append(n)})}function R(t,r){return Reflect.has(globalThis,t)?Promise.resolve(Reflect.get(globalThis,t)):q(r).then(()=>Reflect.get(globalThis,t))}var $=new Array(256);for(let t=0;t<256;t++)$[t]=t.toString(16).padStart(2,"0");function d(t){if(!t||!(t instanceof Uint8Array))throw new TypeError("Input must be a Uint8Array");let r=t.length,i=new Array(r);for(let n=0;n<r;n++)i[n]=$[t[n]];return i.join("")}function A(t){if(typeof t!="string")throw new TypeError("Input must be a string");let r=t.length;if(r%2!==0)throw new TypeError("Hex string must have even length");t=t.toLowerCase();let i=new Uint8Array(r>>1);for(let n=0;n<r;n+=2){let o=t.charCodeAt(n),e=t.charCodeAt(n+1),s=o>=97&&o<=102?o-87:o>=48&&o<=57?o-48:0,a=e>=97&&e<=102?e-87:e>=48&&e<=57?e-48:0;i[n>>1]=s<<4|a}return i}function m(t){let r=new Uint8Array(t);return crypto.getRandomValues(r),r}function W(){let t=m(1);return new Int8Array(t)[0]}function G(){let t=m(1);return new Uint8Array(t)[0]}function u(t,r="utf-8"){if(typeof t!="string")throw new TypeError("Input must be a string");if(r.toLowerCase()!=="utf-8")throw new Error("Only 'utf-8' encoding is supported");return new TextEncoder().encode(t)}function h(t,r="utf-8"){if(t instanceof Uint8Array||(t=new Uint8Array(t)),r.toLowerCase()!=="utf-8")throw new Error("Only 'utf-8' encoding is supported");return new TextDecoder().decode(t)}var _=await R("scrypt",import.meta.resolve("./WebScrypt/scrypt.js"));_.setResPath(import.meta.resolve("./WebScrypt/asset/"));_.load();var O=function(){let t=[],r=!1,i=o=>new Promise(async(e,s)=>{_.onprogress=a=>{o.onprogress&&o.onprogress(a)},_.oncomplete=a=>{o.resolve(a),e(!0)},_.onerror=a=>{o.reject(a),e(!1)};try{_.config({N:o.N,r:o.r,P:o.p},{maxPassLen:8192,maxSaltLen:2048,maxDkLen:1024,maxThread:1}),await new Promise(a=>_.onready=a),_.hash(o.key,o.salt,o.dklen)}catch(a){s(a)}});async function n(){for(;t.length;)try{let o=t.splice(0,1)[0];await i(o),await H()}catch(o){console.error("[scrypt]","Task failed unexpectedly",o)}r=!1}return function(e,s,a,y,c,p,w=null){return new Promise((l,g)=>{t.push({key:e,salt:s,N:a,r:y,p:c,dklen:p,resolve:l,reject:g,onprogress:w}),r||(r=!0,setTimeout(n))})}}(),J=["Furina","Neuvillette","Venti","Nahida","Kinich","Kazuha"];async function v(t,r,i=null,n=null,o=null,e=8,s=1,a=32){if(n===null&&(n=262144),typeof n!="number"||n>2097152)throw new TypeError("Invalid or too large N value!");if(o||(o=m(64)),i||(i=J[G()%J.length]),i.includes(":"))throw new Error('phrase MUST NOT contain ":"');let y=`${i}:${d(o)}`,c=`MyEncryption/1.1 Fontaine/4.2 Iv/${d(r)} user_parameter=${y} user_key=${t}`;return{derived_key:await O(u(c),o,n,e,s,a),parameter:y,N:n}}function H(){return new Promise(t=>setTimeout(t))}async function Q(t,r,i,n,o,e){return d(await O(u(t),u(r),i,n,o,e))}function X(t){try{return JSON.parse(t)}catch{throw new TypeError("Invalid Parameter.")}}async function E(t,r,i=null,n=null){let o=m(12),{derived_key:e,parameter:s,N:a}=await v(r,o,i,n);n=a;let y=await crypto.subtle.importKey("raw",e,"AES-GCM",!1,["encrypt"]);typeof t=="string"&&(t=u(t));let c=await crypto.subtle.encrypt({name:"AES-GCM",iv:o},y,t),p=new Uint8Array(o.length+c.byteLength);p.set(o,0),p.set(new Uint8Array(c),o.length);let w=d(p);return JSON.stringify({data:w,parameter:s,N:n,v:5.5})}async function U(t,r){let i=X(t),n=i.parameter,o=parseInt(i.N),e=A(i.data),[s,a]=n.split(":"),y=A(a);if(isNaN(o)||!n||!e||!y)throw new TypeError("The message or parameters are bad.");if(e.length<28)throw new TypeError("The message was too short.");let c=e.slice(0,12),p=e.slice(12,-16),w=e.slice(-16),{derived_key:l}=await v(r,c,s,o,y),g=await crypto.subtle.importKey("raw",l,"AES-GCM",!1,["decrypt"]),k=await crypto.subtle.decrypt({name:"AES-GCM",iv:c},g,new Uint8Array([...p,...w]));try{return h(k)}catch{return k}}function z(){return new Promise(t=>requestAnimationFrame(t))}async function Y(t,r,i,n=null,o=null,e=null,s=32*1024*1024){await r(u("MyEncryption/1.1"));let a=d(m(64)),y=await E(a,i),c=u(y);if(c.length>1024)throw new Error("(Internal Error) This should not happen. Contact the application developer.");let p=new ArrayBuffer(4);new DataView(p).setUint32(0,c.length,!0),await r(new Uint8Array(p)),await r(c);let w=new Uint8Array(1024-c.length).fill(0);await r(w),n?.(0),await z();let l=m(12),{derived_key:g,parameter:k,N:F}=await v(a,l,o,e);e=F;let P={parameter:k,N:e,v:5.5,iv:d(l)},B=u(JSON.stringify(P)),D=new ArrayBuffer(4);new DataView(D).setUint32(0,B.length,!0),await r(new Uint8Array(D)),await r(B);let x=0,I=1,T=0;n?.(0);let L=await crypto.subtle.importKey("raw",g,{name:"AES-GCM"},!1,["encrypt"]);for(;;){let f=await t(T,T+s);if(f.length===0)break;let b=new ArrayBuffer(12);new DataView(b).setBigUint64(4,BigInt(I)),I++;let N=new Uint8Array(b),K=await crypto.subtle.encrypt({name:"AES-GCM",iv:N},L,f),M=new Uint8Array(K),V=M.slice(-16),j=M.slice(0,-16),S=new ArrayBuffer(8);new DataView(S).setBigUint64(0,BigInt(f.length),!0),await r(new Uint8Array(S)),await r(N),await r(j),await r(V),x+=f.length,T+=f.length,n?.(x)}await r(new Uint8Array([255,253,240,16,19,208,18,24]));let C=new ArrayBuffer(8);return new DataView(C).setBigUint64(0,BigInt(x),!0),await r(new Uint8Array(C)),await r(new Uint8Array([85,170])),!0}async function Z(t,r,i,n=null){let o=await t(0,16);if(h(o)!=="MyEncryption/1.1")throw new TypeError("Invalid file format");let e=16,s=await t(e,e+4),a=new DataView(s.buffer).getUint32(0,!0);e+=4;let y=h(await t(e,e+a));e+=1024;let c=await U(y,i),p=await t(e,e+4),w=new DataView(p.buffer).getUint32(0,!0);e+=4;let l=JSON.parse(h(await t(e,e+w)));e+=w;let[g,k]=l.parameter.split(":"),F=A(k),P=A(l.iv),B=l.N;n?.(0),await z();let{derived_key:D}=await v(c,P,g,B,F),x=0,I=await crypto.subtle.importKey("raw",D,{name:"AES-GCM"},!1,["decrypt"]);for(;;){let f=await t(e,e+8);if(e+=8,f.every((j,S)=>j===[255,253,240,16,19,208,18,24][S]))break;let b=Number(new DataView(f.buffer).getBigUint64(0,!0)),N=await t(e,e+12);e+=12;let K=await t(e,e+b+16);e+=b+16;let M=K,V=await crypto.subtle.decrypt({name:"AES-GCM",iv:N},I,M);await r(new Uint8Array(V)),x+=V.byteLength,n&&n(x)}let T=await t(e,e+8),L=Number(new DataView(T.buffer).getBigUint64(0,!0));e+=8;let C=await t(e,e+2);if(x!==L)throw new TypeError("File corrupted: total bytes mismatch");if(!C.every((f,b)=>f===[85,170][b]))throw new TypeError("Invalid end marker");return!0}async function tt(t,r,i){if(t.size<1044)throw new Error("Data not enough");if(await t.slice(0,16).text()!=="MyEncryption/1.1")throw new TypeError("Invalid file format");let e=new DataView(await t.slice(16,20).arrayBuffer()).getUint32(0,!0),s=await t.slice(20,20+e).arrayBuffer(),a=h(s);return await E(await U(a,r))}async function et(t,r,i){if(t.size<1044)throw new Error("Data not enough");let n=t.slice(0,16);if(await n.text()!=="MyEncryption/1.1")throw new TypeError("Invalid file format");let e=new DataView(await t.slice(16,20).arrayBuffer()).getUint32(0,!0),s=h(await t.slice(20,20+e).arrayBuffer()),a=await E(await U(s,r),i);if(a.length>1024)throw new Error("(Internal Error) This should not happen. Contact the application developer.");let y=a.length,c=new ArrayBuffer(4);new DataView(c).setUint32(0,y,!0);let w=[n,c,u(a)],l=new Uint8Array(1024-a.length).fill(0);return w.push(l),new Blob(w)}export{et as change_file_password,U as decrypt_data,Z as decrypt_file,v as derive_key,E as encrypt_data,Y as encrypt_file,tt as export_master_key,m as get_random_bytes,W as get_random_int8_number,G as get_random_uint8_number,d as hexlify,O as scrypt,Q as scrypt_hex,h as str_decode,u as str_encode,A as unhexlify};
//# sourceMappingURL=main.bundle.js.map
