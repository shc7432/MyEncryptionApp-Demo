function q(e){return new Promise((r,i)=>{let n=document.createElement("script");n.src=e,n.onload=()=>r(n),n.onerror=o=>i(o),document.head.append(n)})}function R(e,r){return Reflect.has(globalThis,e)?Promise.resolve(Reflect.get(globalThis,e)):q(r).then(()=>Reflect.get(globalThis,e))}var H=new Array(256);for(let e=0;e<256;e++)H[e]=e.toString(16).padStart(2,"0");function d(e){if(!e||!(e instanceof Uint8Array))throw new TypeError("Input must be a Uint8Array");let r=e.length,i=new Array(r);for(let n=0;n<r;n++)i[n]=H[e[n]];return i.join("")}var $={get InvalidHexStringException(){throw new TypeError("Invalid hex string")}};function A(e){if(typeof e!="string")throw new TypeError("Input must be a string");let r=e.length;if(r%2!==0)throw new TypeError("Hex string must have even length");e=e.toLowerCase();let i=new Uint8Array(r>>1);for(let n=0;n<r;n+=2){let o=e.charCodeAt(n),t=e.charCodeAt(n+1),s=o>=97&&o<=102?o-87:o>=48&&o<=57?o-48:$.InvalidHexStringException,a=t>=97&&t<=102?t-87:t>=48&&t<=57?t-48:$.InvalidHexStringException;i[n>>1]=s<<4|a}return i}function m(e){let r=new Uint8Array(e);return crypto.getRandomValues(r),r}function W(){let e=m(1);return new Int8Array(e)[0]}function K(){let e=m(1);return new Uint8Array(e)[0]}function u(e,r="utf-8"){if(typeof e!="string")throw new TypeError("Input must be a string");if(r.toLowerCase()!=="utf-8")throw new Error("Only 'utf-8' encoding is supported");return new TextEncoder().encode(e)}function h(e,r="utf-8"){if(e instanceof Uint8Array||(e=new Uint8Array(e)),r.toLowerCase()!=="utf-8")throw new Error("Only 'utf-8' encoding is supported");return new TextDecoder().decode(e)}var _=await R("scrypt",import.meta.resolve("./WebScrypt/scrypt.js"));_.setResPath(import.meta.resolve("./WebScrypt/asset/"));_.load();var O=function(){let e=[],r=!1,i=o=>new Promise(async(t,s)=>{_.onprogress=a=>{o.onprogress&&o.onprogress(a)},_.oncomplete=a=>{o.resolve(a),t(!0)},_.onerror=a=>{o.reject(a),t(!1)};try{_.config({N:o.N,r:o.r,P:o.p},{maxPassLen:8192,maxSaltLen:2048,maxDkLen:1024,maxThread:1}),await new Promise(a=>_.onready=a),_.hash(o.key,o.salt,o.dklen)}catch(a){s(a)}});async function n(){let o=null;for(;e.length;)try{o=e.splice(0,1)[0],await i(o),await X()}catch(t){console.error("[scrypt]","Task failed unexpectedly",t),o?.reject(t)}r=!1}return function(t,s,a,y,c,p,w=null){return new Promise((l,g)=>{e.push({key:t,salt:s,N:a,r:y,p:c,dklen:p,resolve:l,reject:g,onprogress:w}),r||(r=!0,setTimeout(n))})}}(),J=["Furina","Neuvillette","Venti","Nahida","Kinich","Kazuha"];async function v(e,r,i=null,n=null,o=null,t=8,s=1,a=32){if(n===null&&(n=262144),typeof n!="number"||n>2097152)throw new TypeError("Invalid or too large N value!");if(o||(o=m(64)),i||(i=J[K()%J.length]),i.includes(":"))throw new Error('phrase MUST NOT contain ":"');let y=`${i}:${d(o)}`,c=`MyEncryption/1.1 Fontaine/4.2 Iv/${d(r)} user_parameter=${y} user_key=${e}`;return{derived_key:await O(u(c),o,n,t,s,a),parameter:y,N:n}}function X(){return new Promise(e=>setTimeout(e))}async function Q(e,r,i,n,o,t){return d(await O(u(e),u(r),i,n,o,t))}function Y(e){try{return JSON.parse(e)}catch{throw new TypeError("Invalid Parameter.")}}async function T(e,r,i=null,n=null){let o=m(12),{derived_key:t,parameter:s,N:a}=await v(r,o,i,n);n=a;let y=await crypto.subtle.importKey("raw",t,"AES-GCM",!1,["encrypt"]);typeof e=="string"&&(e=u(e));let c=await crypto.subtle.encrypt({name:"AES-GCM",iv:o},y,e),p=new Uint8Array(o.length+c.byteLength);p.set(o,0),p.set(new Uint8Array(c),o.length);let w=d(p);return JSON.stringify({data:w,parameter:s,N:n,v:5.5})}async function U(e,r){let i=Y(e),n=i.parameter,o=parseInt(i.N),t=A(i.data),[s,a]=n.split(":"),y=A(a);if(isNaN(o)||!n||!t||!y)throw new TypeError("The message or parameters are bad.");if(t.length<28)throw new TypeError("The message was too short.");let c=t.slice(0,12),p=t.slice(12,-16),w=t.slice(-16),{derived_key:l}=await v(r,c,s,o,y),g=await crypto.subtle.importKey("raw",l,"AES-GCM",!1,["decrypt"]),E=await crypto.subtle.decrypt({name:"AES-GCM",iv:c},g,new Uint8Array([...p,...w]));try{return h(E)}catch{return E}}function z(){return new Promise(e=>requestAnimationFrame(e))}async function Z(e,r,i,n=null,o=null,t=null,s=32*1024*1024){await r(u("MyEncryption/1.1"));let a=d(m(64)),y=await T(a,i),c=u(y);if(c.length>1024)throw new Error("(Internal Error) This should not happen. Contact the application developer.");let p=new ArrayBuffer(4);new DataView(p).setUint32(0,c.length,!0),await r(new Uint8Array(p)),await r(c);let w=new Uint8Array(1024-c.length).fill(0);await r(w),n?.(0),await z();let l=m(12),{derived_key:g,parameter:E,N:F}=await v(a,l,o,t);t=F;let P={parameter:E,N:t,v:5.5,iv:d(l)},I=u(JSON.stringify(P)),D=new ArrayBuffer(4);new DataView(D).setUint32(0,I.length,!0),await r(new Uint8Array(D)),await r(I);let x=0,k=1,B=0;n?.(0);let L=await crypto.subtle.importKey("raw",g,{name:"AES-GCM"},!1,["encrypt"]);for(;;){let f=await e(B,B+s);if(f.length===0)break;let b=new ArrayBuffer(12);if(k>=2**64||k>=Number.MAX_SAFE_INTEGER)throw new Error("FATAL: IV Exception: nonce_counter exceeded the maximum value.");new DataView(b).setBigUint64(4,BigInt(k)),k++;let N=new Uint8Array(b),j=await crypto.subtle.encrypt({name:"AES-GCM",iv:N},L,f),S=new Uint8Array(j),M=S.slice(-16),G=S.slice(0,-16),V=new ArrayBuffer(8);new DataView(V).setBigUint64(0,BigInt(f.length),!0),await r(new Uint8Array(V)),await r(N),await r(G),await r(M),x+=f.length,B+=f.length,n?.(x)}await r(new Uint8Array([255,253,240,16,19,208,18,24]));let C=new ArrayBuffer(8);return new DataView(C).setBigUint64(0,BigInt(x),!0),await r(new Uint8Array(C)),await r(new Uint8Array([85,170])),!0}async function ee(e,r,i,n=null){let o=await e(0,16);if(h(o)!=="MyEncryption/1.1")throw new TypeError("Invalid file format");let t=16,s=await e(t,t+4),a=new DataView(s.buffer).getUint32(0,!0);t+=4;let y=h(await e(t,t+a));t+=1024;let c=await U(y,i),p=await e(t,t+4),w=new DataView(p.buffer).getUint32(0,!0);t+=4;let l=JSON.parse(h(await e(t,t+w)));t+=w;let[g,E]=l.parameter.split(":"),F=A(E),P=A(l.iv),I=l.N;n?.(0),await z();let{derived_key:D}=await v(c,P,g,I,F),x=0,k=await crypto.subtle.importKey("raw",D,{name:"AES-GCM"},!1,["decrypt"]);for(;;){let f=await e(t,t+8);if(t+=8,f.every((G,V)=>G===[255,253,240,16,19,208,18,24][V]))break;let b=Number(new DataView(f.buffer).getBigUint64(0,!0)),N=await e(t,t+12);t+=12;let j=await e(t,t+b+16);t+=b+16;let S=j,M=await crypto.subtle.decrypt({name:"AES-GCM",iv:N},k,S);await r(new Uint8Array(M)),x+=M.byteLength,n&&n(x)}let B=await e(t,t+8),L=Number(new DataView(B.buffer).getBigUint64(0,!0));t+=8;let C=await e(t,t+2);if(x!==L)throw new TypeError("File corrupted: total bytes mismatch");if(!C.every((f,b)=>f===[85,170][b]))throw new TypeError("Invalid end marker");return!0}async function te(e,r,i){if(e.size<1044)throw new Error("Data not enough");if(await e.slice(0,16).text()!=="MyEncryption/1.1")throw new TypeError("Invalid file format");let t=new DataView(await e.slice(16,20).arrayBuffer()).getUint32(0,!0),s=await e.slice(20,20+t).arrayBuffer(),a=h(s);return await T(await U(a,r))}async function re(e,r,i){if(e.size<1044)throw new Error("Data not enough");let n=e.slice(0,16);if(await n.text()!=="MyEncryption/1.1")throw new TypeError("Invalid file format");let t=new DataView(await e.slice(16,20).arrayBuffer()).getUint32(0,!0),s=h(await e.slice(20,20+t).arrayBuffer()),a=await T(await U(s,r),i);if(a.length>1024)throw new Error("(Internal Error) This should not happen. Contact the application developer.");let y=a.length,c=new ArrayBuffer(4);new DataView(c).setUint32(0,y,!0);let w=[n,c,u(a)],l=new Uint8Array(1024-a.length).fill(0);return w.push(l),new Blob(w)}export{re as change_file_password,U as decrypt_data,ee as decrypt_file,v as derive_key,T as encrypt_data,Z as encrypt_file,te as export_master_key,m as get_random_bytes,W as get_random_int8_number,K as get_random_uint8_number,d as hexlify,O as scrypt,Q as scrypt_hex,h as str_decode,u as str_encode,A as unhexlify};
//# sourceMappingURL=main.bundle.js.map
