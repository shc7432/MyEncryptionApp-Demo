function z(t){return new Promise((r,a)=>{let n=document.createElement("script");n.src=t,n.onload=()=>r(n),n.onerror=o=>a(o),document.head.append(n)})}function $(t,r){return Reflect.has(globalThis,t)?Promise.resolve(Reflect.get(globalThis,t)):z(r).then(()=>Reflect.get(globalThis,t))}function m(t){if(!t||!(t instanceof Uint8Array))throw new TypeError("Input must be a Uint8Array");return Array.from(t).map(r=>r.toString(16).padStart(2,"0")).join("")}function v(t){if(typeof t!="string")throw new TypeError("Input must be a string");if(t.length%2!==0)throw new TypeError("Hex string must have even length");if(!/^[0-9a-fA-F]*$/.test(t))throw new TypeError("Hex string contains invalid characters");let r=new Uint8Array(t.length/2);for(let a=0;a<t.length;a+=2)r[a/2]=parseInt(t.substring(a,a+2),16);return r}function d(t){let r=new Uint8Array(t);return crypto.getRandomValues(r),r}function q(){let t=d(1);return new Int8Array(t)[0]}function G(){let t=d(1);return new Uint8Array(t)[0]}function u(t,r="utf-8"){if(typeof t!="string")throw new TypeError("Input must be a string");if(r.toLowerCase()!=="utf-8")throw new Error("Only 'utf-8' encoding is supported");return new TextEncoder().encode(t)}function h(t,r="utf-8"){if(t instanceof Uint8Array||(t=new Uint8Array(t)),r.toLowerCase()!=="utf-8")throw new Error("Only 'utf-8' encoding is supported");return new TextDecoder().decode(t)}var _=await $("scrypt",import.meta.resolve("./WebScrypt/scrypt.js"));_.setResPath(import.meta.resolve("./WebScrypt/asset/"));_.load();var O=function(){let t=[],r=!1,a=o=>new Promise(async e=>{_.onprogress=i=>{o.onprogress&&o.onprogress(i)},_.oncomplete=i=>{o.resolve(i),e(!0)},_.onerror=i=>{o.reject(i),e(!1)},_.config({N:o.N,r:o.r,P:o.p},{maxPassLen:1024,maxSaltLen:1024,maxDkLen:1024,maxThread:1}),await new Promise(i=>_.onready=i),_.hash(o.key,o.salt,o.dklen)});async function n(){for(;t.length;)try{let o=t.splice(0,1)[0];await a(o),await H()}catch(o){console.error("[scrypt]","Task failed",o)}r=!1}return function(e,i,c,y,s,p,w=null){return new Promise((f,g)=>{t.push({key:e,salt:i,N:c,r:y,p:s,dklen:p,resolve:f,reject:g,onprogress:w}),r||(r=!0,setTimeout(n))})}}(),R=["Furina","Neuvillette","Venti","Nahida","Kinich","Kazuha"];async function A(t,r,a=null,n=null,o=null,e=8,i=1,c=32){if(n===null&&(n=262144),typeof n!="number"||n>2097152)throw new TypeError("Invalid or too large N value!");if(o||(o=d(64)),a||(a=R[G()%R.length]),a.includes(":"))throw new Error('phrase MUST NOT contain ":"');let y=`${a}:${m(o)}`,s=`MyEncryption/1.1 Fontaine/4.2 Iv/${m(r)} user_parameter=${y} user_key=${t}`;return{derived_key:await O(u(s),o,n,e,i,c),parameter:y,N:n}}function H(){return new Promise(t=>setTimeout(t))}async function W(t,r,a,n,o,e){return m(await O(u(t),u(r),a,n,o,e))}function Q(t){try{return JSON.parse(t)}catch{throw new TypeError("Invalid Parameter.")}}async function U(t,r,a=null,n=null){let o=d(12),{derived_key:e,parameter:i,N:c}=await A(r,o,a,n);n=c;let y=await crypto.subtle.importKey("raw",e,"AES-GCM",!1,["encrypt"]);typeof t=="string"&&(t=u(t));let s=await crypto.subtle.encrypt({name:"AES-GCM",iv:o},y,t),p=new Uint8Array(o.length+s.byteLength);p.set(o,0),p.set(new Uint8Array(s),o.length);let w=m(p);return JSON.stringify({data:w,parameter:i,N:n,v:5.5})}async function k(t,r){let a=Q(t),n=a.parameter,o=parseInt(a.N),e=v(a.data),[i,c]=n.split(":"),y=v(c);if(isNaN(o)||!n||!e||!y)throw new TypeError("The message or parameters are bad.");if(e.length<28)throw new TypeError("The message was too short.");let s=e.slice(0,12),p=e.slice(12,-16),w=e.slice(-16),{derived_key:f}=await A(r,s,i,o,y),g=await crypto.subtle.importKey("raw",f,"AES-GCM",!1,["decrypt"]),E=await crypto.subtle.decrypt({name:"AES-GCM",iv:s},g,new Uint8Array([...p,...w]));try{return h(E)}catch{return E}}function J(){return new Promise(t=>requestAnimationFrame(t))}async function X(t,r,a,n=null,o=null,e=null,i=32*1024*1024){await r(u("MyEncryption/1.1"));let c=m(d(64)),y=await U(c,a),s=u(y);if(s.length>1024)throw new Error("(Internal Error) This should not happen. Contact the application developer.");let p=new ArrayBuffer(4);new DataView(p).setUint32(0,s.length,!0),await r(new Uint8Array(p)),await r(s);let w=new Uint8Array(1024-s.length).fill(0);await r(w),n&&n(0),await J();let f=d(12),{derived_key:g,parameter:E,N:P}=await A(c,f,o,e);e=P;let C={parameter:E,N:e,v:5.5,iv:m(f)},T=u(JSON.stringify(C)),D=new ArrayBuffer(4);new DataView(D).setUint32(0,T.length,!0),await r(new Uint8Array(D)),await r(T);let x=0,I=1,B=0;n&&n(0);let K=await crypto.subtle.importKey("raw",g,{name:"AES-GCM"},!1,["encrypt"]);for(;;){let l=await t(B,B+i);if(l.length===0)break;let b=new ArrayBuffer(12);new DataView(b).setBigUint64(4,BigInt(I)),I++;let M=new Uint8Array(b),L=await crypto.subtle.encrypt({name:"AES-GCM",iv:M},K,l),V=new Uint8Array(L),F=V.slice(-16),j=V.slice(0,-16),S=new ArrayBuffer(8);new DataView(S).setBigUint64(0,BigInt(l.length),!0),await r(new Uint8Array(S)),await r(M),await r(j),await r(F),x+=l.length,B+=l.length,n&&n(x)}await r(new Uint8Array([255,253,240,16,19,208,18,24]));let N=new ArrayBuffer(8);return new DataView(N).setBigUint64(0,BigInt(x),!0),await r(new Uint8Array(N)),await r(new Uint8Array([85,170])),!0}async function Y(t,r,a,n=null){let o=await t(0,16);if(h(o)!=="MyEncryption/1.1")throw new TypeError("Invalid file format");let e=16,i=await t(e,e+4),c=new DataView(i.buffer).getUint32(0,!0);e+=4;let y=h(await t(e,e+c));e+=1024;let s=await k(y,a),p=await t(e,e+4),w=new DataView(p.buffer).getUint32(0,!0);e+=4;let f=JSON.parse(h(await t(e,e+w)));e+=w;let[g,E]=f.parameter.split(":"),P=v(E),C=v(f.iv),T=f.N;n&&n(0),await J();let{derived_key:D}=await A(s,C,g,T,P),x=0,I=await crypto.subtle.importKey("raw",D,{name:"AES-GCM"},!1,["decrypt"]);for(;;){let l=await t(e,e+8);if(e+=8,l.every((j,S)=>j===[255,253,240,16,19,208,18,24][S]))break;let b=Number(new DataView(l.buffer).getBigUint64(0,!0)),M=await t(e,e+12);e+=12;let L=await t(e,e+b+16);e+=b+16;let V=L,F=await crypto.subtle.decrypt({name:"AES-GCM",iv:M},I,V);await r(new Uint8Array(F)),x+=F.byteLength,n&&n(x)}let B=await t(e,e+8),K=Number(new DataView(B.buffer).getBigUint64(0,!0));e+=8;let N=await t(e,e+2);if(x!==K)throw new TypeError("File corrupted: total bytes mismatch");if(!N.every((l,b)=>l===[85,170][b]))throw new TypeError("Invalid end marker");return!0}async function Z(t,r,a){if(t.size<1044)throw new Error("Data not enough");if(await t.slice(0,16).text()!=="MyEncryption/1.1")throw new TypeError("Invalid file format");let e=new DataView(await t.slice(16,20).arrayBuffer()).getUint32(0,!0),i=await t.slice(20,20+e).arrayBuffer(),c=h(i);return await U(await k(c,r))}async function tt(t,r,a){if(t.size<1044)throw new Error("Data not enough");let n=t.slice(0,16);if(await n.text()!=="MyEncryption/1.1")throw new TypeError("Invalid file format");let e=new DataView(await t.slice(16,20).arrayBuffer()).getUint32(0,!0),i=h(await t.slice(20,20+e).arrayBuffer()),c=await U(await k(i,r),a),y=c.length,s=new ArrayBuffer(4);new DataView(s).setUint32(0,y,!0);let w=[n,s,u(c)],f=new Uint8Array(1024-c.length).fill(0);return w.push(f),new Blob(w)}export{tt as change_file_password,k as decrypt_data,Y as decrypt_file,A as derive_key,U as encrypt_data,X as encrypt_file,Z as export_master_key,d as get_random_bytes,q as get_random_int8_number,G as get_random_uint8_number,m as hexlify,O as scrypt,W as scrypt_hex,h as str_decode,u as str_encode,v as unhexlify};
//# sourceMappingURL=main.bundle.js.map
