function q(t){return new Promise((r,a)=>{let o=document.createElement("script");o.src=t,o.onload=()=>r(o),o.onerror=n=>a(n),document.head.append(o)})}function G(t,r){return Reflect.has(globalThis,t)?Promise.resolve(Reflect.get(globalThis,t)):q(r).then(()=>Reflect.get(globalThis,t))}function d(t){if(!t||!(t instanceof Uint8Array))throw new TypeError("Input must be a Uint8Array");return Array.from(t).map(r=>r.toString(16).padStart(2,"0")).join("")}function E(t){if(typeof t!="string")throw new TypeError("Input must be a string");if(t.length%2!==0)throw new TypeError("Hex string must have even length");if(!/^[0-9a-fA-F]*$/.test(t))throw new TypeError("Hex string contains invalid characters");let r=new Uint8Array(t.length/2);for(let a=0;a<t.length;a+=2)r[a/2]=parseInt(t.substring(a,a+2),16);return r}function l(t){let r=new Uint8Array(t);return crypto.getRandomValues(r),r}function O(){let t=l(1);return new Uint8Array(t)[0]}function m(t,r="utf-8"){if(typeof t!="string")throw new TypeError("Input must be a string");if(r.toLowerCase()!=="utf-8")throw new Error("Only 'utf-8' encoding is supported");return new TextEncoder().encode(t)}function h(t,r="utf-8"){if(t instanceof Uint8Array||(t=new Uint8Array(t)),r.toLowerCase()!=="utf-8")throw new Error("Only 'utf-8' encoding is supported");return new TextDecoder().decode(t)}var g=await G("scrypt",import.meta.resolve("./WebScrypt/scrypt.js"));g.setResPath(import.meta.resolve("./WebScrypt/asset/"));g.load();var R=function(){let t=[],r=!1,a=n=>new Promise(async e=>{g.onprogress=i=>{n.onprogress&&n.onprogress(i)},g.oncomplete=i=>{n.resolve(i),e(!0)},g.onerror=i=>{n.reject(i),e(!1)},g.config({N:n.N,r:n.r,P:n.p},{maxPassLen:1024,maxSaltLen:1024,maxDkLen:1024,maxThread:1}),await new Promise(i=>g.onready=i),g.hash(n.key,n.salt,n.dklen)});async function o(){for(;t.length;)try{let n=t.splice(0,1)[0];await a(n),await z()}catch(n){console.error("[scrypt]","Task failed",n)}r=!1}return function(e,i,y,c,s,p,u=null){return new Promise((w,_)=>{t.push({key:e,salt:i,N:y,r:c,p:s,dklen:p,resolve:w,reject:_,onprogress:u}),r||(r=!0,setTimeout(o))})}}(),$=["Furina","Neuvillette","Venti","Nahida","Kinich","Kazuha"];async function b(t,r,a=null,o=null,n=null,e=8,i=1,y=32){if(o===null&&(o=262144),typeof o!="number"||o>2097152)throw new TypeError("Invalid or too large N value!");if(n||(n=l(64)),a||(a=$[O()%$.length]),a.includes(":"))throw new Error('phrase MUST NOT contain ":"');let c=`${a}:${d(n)}`,s=`MyEncryption/1.1 Fontaine/4.2 Iv/${d(r)} user_parameter=${c} user_key=${t}`;return{derived_key:await R(m(s),n,o,e,i,y),parameter:c,N:o}}function z(){return new Promise(t=>setTimeout(t))}function H(t){try{return JSON.parse(t)}catch{throw new TypeError("Invalid Parameter.")}}async function T(t,r,a=null,o=null){let n=l(12),{derived_key:e,parameter:i,N:y}=await b(r,n,a,o);o=y;let c=await crypto.subtle.importKey("raw",e,"AES-GCM",!1,["encrypt"]);typeof t=="string"&&(t=m(t));let s=await crypto.subtle.encrypt({name:"AES-GCM",iv:n},c,t),p=new Uint8Array(n.length+s.byteLength);p.set(n,0),p.set(new Uint8Array(s),n.length);let u=d(p);return JSON.stringify({data:u,parameter:i,N:o,v:5.5})}async function k(t,r){let a=H(t),o=a.parameter,n=parseInt(a.N),e=E(a.data),[i,y]=o.split(":"),c=E(y);if(isNaN(n)||!o||!e||!c)throw new TypeError("The message or parameters are bad.");if(e.length<28)throw new TypeError("The message was too short.");let s=e.slice(0,12),p=e.slice(12,-16),u=e.slice(-16),{derived_key:w}=await b(r,s,i,n,c),_=await crypto.subtle.importKey("raw",w,"AES-GCM",!1,["decrypt"]),v=await crypto.subtle.decrypt({name:"AES-GCM",iv:s},_,new Uint8Array([...p,...u]));try{return h(v)}catch{return v}}function J(){return new Promise(t=>requestAnimationFrame(t))}async function W(t,r,a,o=null,n=null,e=null,i=32*1024*1024){await r(m("MyEncryption/1.1"));let y=d(l(64)),c=await T(y,a),s=m(c);if(s.length>1024)throw new Error("(Internal Error) This should not happen. Contact the application developer.");let p=new ArrayBuffer(4);new DataView(p).setUint32(0,s.length,!0),await r(new Uint8Array(p)),await r(s);let u=new Uint8Array(1024-s.length).fill(0);await r(u),o&&o(0),await J();let w=l(12),{derived_key:_,parameter:v,N:V}=await b(y,w,n,e);e=V;let C={parameter:v,N:e,v:5.5,iv:d(w)},B=m(JSON.stringify(C)),D=new ArrayBuffer(4);new DataView(D).setUint32(0,B.length,!0),await r(new Uint8Array(D)),await r(B);let x=0,I=1,U=0;o&&o(0);let K=await crypto.subtle.importKey("raw",_,{name:"AES-GCM"},!1,["encrypt"]);for(;;){let f=await t(U,U+i);if(f.length===0)break;let A=new ArrayBuffer(12);new DataView(A).setBigUint64(4,BigInt(I)),I++;let F=new Uint8Array(A),L=await crypto.subtle.encrypt({name:"AES-GCM",iv:F},K,f),M=new Uint8Array(L),S=M.slice(-16),j=M.slice(0,-16),P=new ArrayBuffer(8);new DataView(P).setBigUint64(0,BigInt(f.length),!0),await r(new Uint8Array(P)),await r(F),await r(j),await r(S),x+=f.length,U+=f.length,o&&o(x)}await r(new Uint8Array([255,253,240,16,19,208,18,24]));let N=new ArrayBuffer(8);return new DataView(N).setBigUint64(0,BigInt(x),!0),await r(new Uint8Array(N)),await r(new Uint8Array([85,170])),!0}async function Q(t,r,a,o=null){let n=await t(0,16);if(h(n)!=="MyEncryption/1.1")throw new TypeError("Invalid file format");let e=16,i=await t(e,e+4),y=new DataView(i.buffer).getUint32(0,!0);e+=4;let c=h(await t(e,e+y));e+=1024;let s=await k(c,a),p=await t(e,e+4),u=new DataView(p.buffer).getUint32(0,!0);e+=4;let w=JSON.parse(h(await t(e,e+u)));e+=u;let[_,v]=w.parameter.split(":"),V=E(v),C=E(w.iv),B=w.N;o&&o(0),await J();let{derived_key:D}=await b(s,C,_,B,V),x=0,I=await crypto.subtle.importKey("raw",D,{name:"AES-GCM"},!1,["decrypt"]);for(;;){let f=await t(e,e+8);if(e+=8,f.every((j,P)=>j===[255,253,240,16,19,208,18,24][P]))break;let A=Number(new DataView(f.buffer).getBigUint64(0,!0)),F=await t(e,e+12);e+=12;let L=await t(e,e+A+16);e+=A+16;let M=L,S=await crypto.subtle.decrypt({name:"AES-GCM",iv:F},I,M);await r(new Uint8Array(S)),x+=S.byteLength,o&&o(x)}let U=await t(e,e+8),K=Number(new DataView(U.buffer).getBigUint64(0,!0));e+=8;let N=await t(e,e+2);if(x!==K)throw new TypeError("File corrupted: total bytes mismatch");if(!N.every((f,A)=>f===[85,170][A]))throw new TypeError("Invalid end marker");return!0}async function X(t,r,a){if(t.size<1044)throw new Error("Data not enough");if(await t.slice(0,16).text()!=="MyEncryption/1.1")throw new TypeError("Invalid file format");let e=new DataView(await t.slice(16,20).arrayBuffer()).getUint32(0,!0),i=await t.slice(20,20+e).arrayBuffer(),y=h(i),c=await k(y,r);return await T(c,a)}export{k as decrypt_data,Q as decrypt_file,b as derive_key,T as encrypt_data,W as encrypt_file,X as export_master_key,R as scrypt};
//# sourceMappingURL=main.bundle.js.map
