function q(t){return new Promise((n,a)=>{let r=document.createElement("script");r.src=t,r.onload=()=>n(r),r.onerror=o=>a(o),document.head.append(r)})}function R(t,n){return Reflect.has(globalThis,t)?Promise.resolve(Reflect.get(globalThis,t)):q(n).then(()=>Reflect.get(globalThis,t))}var $=new Array(256);for(let t=0;t<256;t++)$[t]=t.toString(16).padStart(2,"0");function d(t){if(!t||!(t instanceof Uint8Array))throw new TypeError("Input must be a Uint8Array");let n=t.length,a=new Array(n);for(let r=0;r<n;r++)a[r]=$[t[r]];return a.join("")}function A(t){if(typeof t!="string")throw new TypeError("Input must be a string");let n=t.length;if(n%2!==0)throw new TypeError("Hex string must have even length");t=t.toLowerCase();let a=new Uint8Array(n>>1);for(let r=0;r<n;r+=2){let o=t.charCodeAt(r),e=t.charCodeAt(r+1),i=o>=97&&o<=102?o-87:o>=48&&o<=57?o-48:0,s=e>=97&&e<=102?e-87:e>=48&&e<=57?e-48:0;a[r>>1]=i<<4|s}return a}function m(t){let n=new Uint8Array(t);return crypto.getRandomValues(n),n}function W(){let t=m(1);return new Int8Array(t)[0]}function G(){let t=m(1);return new Uint8Array(t)[0]}function u(t,n="utf-8"){if(typeof t!="string")throw new TypeError("Input must be a string");if(n.toLowerCase()!=="utf-8")throw new Error("Only 'utf-8' encoding is supported");return new TextEncoder().encode(t)}function h(t,n="utf-8"){if(t instanceof Uint8Array||(t=new Uint8Array(t)),n.toLowerCase()!=="utf-8")throw new Error("Only 'utf-8' encoding is supported");return new TextDecoder().decode(t)}var _=await R("scrypt",import.meta.resolve("./WebScrypt/scrypt.js"));_.setResPath(import.meta.resolve("./WebScrypt/asset/"));_.load();var O=function(){let t=[],n=!1,a=o=>new Promise(async e=>{_.onprogress=i=>{o.onprogress&&o.onprogress(i)},_.oncomplete=i=>{o.resolve(i),e(!0)},_.onerror=i=>{o.reject(i),e(!1)},_.config({N:o.N,r:o.r,P:o.p},{maxPassLen:1024,maxSaltLen:1024,maxDkLen:1024,maxThread:1}),await new Promise(i=>_.onready=i),_.hash(o.key,o.salt,o.dklen)});async function r(){for(;t.length;)try{let o=t.splice(0,1)[0];await a(o),await H()}catch(o){console.error("[scrypt]","Task failed",o)}n=!1}return function(e,i,s,y,c,p,w=null){return new Promise((f,g)=>{t.push({key:e,salt:i,N:s,r:y,p:c,dklen:p,resolve:f,reject:g,onprogress:w}),n||(n=!0,setTimeout(r))})}}(),J=["Furina","Neuvillette","Venti","Nahida","Kinich","Kazuha"];async function v(t,n,a=null,r=null,o=null,e=8,i=1,s=32){if(r===null&&(r=262144),typeof r!="number"||r>2097152)throw new TypeError("Invalid or too large N value!");if(o||(o=m(64)),a||(a=J[G()%J.length]),a.includes(":"))throw new Error('phrase MUST NOT contain ":"');let y=`${a}:${d(o)}`,c=`MyEncryption/1.1 Fontaine/4.2 Iv/${d(n)} user_parameter=${y} user_key=${t}`;return{derived_key:await O(u(c),o,r,e,i,s),parameter:y,N:r}}function H(){return new Promise(t=>setTimeout(t))}async function Q(t,n,a,r,o,e){return d(await O(u(t),u(n),a,r,o,e))}function X(t){try{return JSON.parse(t)}catch{throw new TypeError("Invalid Parameter.")}}async function U(t,n,a=null,r=null){let o=m(12),{derived_key:e,parameter:i,N:s}=await v(n,o,a,r);r=s;let y=await crypto.subtle.importKey("raw",e,"AES-GCM",!1,["encrypt"]);typeof t=="string"&&(t=u(t));let c=await crypto.subtle.encrypt({name:"AES-GCM",iv:o},y,t),p=new Uint8Array(o.length+c.byteLength);p.set(o,0),p.set(new Uint8Array(c),o.length);let w=d(p);return JSON.stringify({data:w,parameter:i,N:r,v:5.5})}async function k(t,n){let a=X(t),r=a.parameter,o=parseInt(a.N),e=A(a.data),[i,s]=r.split(":"),y=A(s);if(isNaN(o)||!r||!e||!y)throw new TypeError("The message or parameters are bad.");if(e.length<28)throw new TypeError("The message was too short.");let c=e.slice(0,12),p=e.slice(12,-16),w=e.slice(-16),{derived_key:f}=await v(n,c,i,o,y),g=await crypto.subtle.importKey("raw",f,"AES-GCM",!1,["decrypt"]),E=await crypto.subtle.decrypt({name:"AES-GCM",iv:c},g,new Uint8Array([...p,...w]));try{return h(E)}catch{return E}}function z(){return new Promise(t=>requestAnimationFrame(t))}async function Y(t,n,a,r=null,o=null,e=null,i=32*1024*1024){await n(u("MyEncryption/1.1"));let s=d(m(64)),y=await U(s,a),c=u(y);if(c.length>1024)throw new Error("(Internal Error) This should not happen. Contact the application developer.");let p=new ArrayBuffer(4);new DataView(p).setUint32(0,c.length,!0),await n(new Uint8Array(p)),await n(c);let w=new Uint8Array(1024-c.length).fill(0);await n(w),r&&r(0),await z();let f=m(12),{derived_key:g,parameter:E,N:F}=await v(s,f,o,e);e=F;let P={parameter:E,N:e,v:5.5,iv:d(f)},T=u(JSON.stringify(P)),D=new ArrayBuffer(4);new DataView(D).setUint32(0,T.length,!0),await n(new Uint8Array(D)),await n(T);let x=0,I=1,B=0;r&&r(0);let L=await crypto.subtle.importKey("raw",g,{name:"AES-GCM"},!1,["encrypt"]);for(;;){let l=await t(B,B+i);if(l.length===0)break;let b=new ArrayBuffer(12);new DataView(b).setBigUint64(4,BigInt(I)),I++;let N=new Uint8Array(b),K=await crypto.subtle.encrypt({name:"AES-GCM",iv:N},L,l),M=new Uint8Array(K),V=M.slice(-16),j=M.slice(0,-16),S=new ArrayBuffer(8);new DataView(S).setBigUint64(0,BigInt(l.length),!0),await n(new Uint8Array(S)),await n(N),await n(j),await n(V),x+=l.length,B+=l.length,r&&r(x)}await n(new Uint8Array([255,253,240,16,19,208,18,24]));let C=new ArrayBuffer(8);return new DataView(C).setBigUint64(0,BigInt(x),!0),await n(new Uint8Array(C)),await n(new Uint8Array([85,170])),!0}async function Z(t,n,a,r=null){let o=await t(0,16);if(h(o)!=="MyEncryption/1.1")throw new TypeError("Invalid file format");let e=16,i=await t(e,e+4),s=new DataView(i.buffer).getUint32(0,!0);e+=4;let y=h(await t(e,e+s));e+=1024;let c=await k(y,a),p=await t(e,e+4),w=new DataView(p.buffer).getUint32(0,!0);e+=4;let f=JSON.parse(h(await t(e,e+w)));e+=w;let[g,E]=f.parameter.split(":"),F=A(E),P=A(f.iv),T=f.N;r&&r(0),await z();let{derived_key:D}=await v(c,P,g,T,F),x=0,I=await crypto.subtle.importKey("raw",D,{name:"AES-GCM"},!1,["decrypt"]);for(;;){let l=await t(e,e+8);if(e+=8,l.every((j,S)=>j===[255,253,240,16,19,208,18,24][S]))break;let b=Number(new DataView(l.buffer).getBigUint64(0,!0)),N=await t(e,e+12);e+=12;let K=await t(e,e+b+16);e+=b+16;let M=K,V=await crypto.subtle.decrypt({name:"AES-GCM",iv:N},I,M);await n(new Uint8Array(V)),x+=V.byteLength,r&&r(x)}let B=await t(e,e+8),L=Number(new DataView(B.buffer).getBigUint64(0,!0));e+=8;let C=await t(e,e+2);if(x!==L)throw new TypeError("File corrupted: total bytes mismatch");if(!C.every((l,b)=>l===[85,170][b]))throw new TypeError("Invalid end marker");return!0}async function tt(t,n,a){if(t.size<1044)throw new Error("Data not enough");if(await t.slice(0,16).text()!=="MyEncryption/1.1")throw new TypeError("Invalid file format");let e=new DataView(await t.slice(16,20).arrayBuffer()).getUint32(0,!0),i=await t.slice(20,20+e).arrayBuffer(),s=h(i);return await U(await k(s,n))}async function et(t,n,a){if(t.size<1044)throw new Error("Data not enough");let r=t.slice(0,16);if(await r.text()!=="MyEncryption/1.1")throw new TypeError("Invalid file format");let e=new DataView(await t.slice(16,20).arrayBuffer()).getUint32(0,!0),i=h(await t.slice(20,20+e).arrayBuffer()),s=await U(await k(i,n),a),y=s.length,c=new ArrayBuffer(4);new DataView(c).setUint32(0,y,!0);let w=[r,c,u(s)],f=new Uint8Array(1024-s.length).fill(0);return w.push(f),new Blob(w)}export{et as change_file_password,k as decrypt_data,Z as decrypt_file,v as derive_key,U as encrypt_data,Y as encrypt_file,tt as export_master_key,m as get_random_bytes,W as get_random_int8_number,G as get_random_uint8_number,d as hexlify,O as scrypt,Q as scrypt_hex,h as str_decode,u as str_encode,A as unhexlify};
//# sourceMappingURL=main.bundle.js.map
